# The 12-byte ObjectId consists of: 
- A 4-byte timestamp, representing the ObjectId's creation, measured in seconds since the Unix epoch. 
- A 5-byte random value generated once per process. This random value is unique to the machine and process. 
- A 3-byte incrementing counter, initialized to a random value. 
# Bson Type 
Double "double"

String "string" 

Object "object" 
Array "array" 
Binary data "binData" 
Undefined "undefined" Deprecated. 
ObjectId "objectId" 
Boolean "bool" Date "date" Null "null" Regular Expression "regex" DBPointer "dbPointer" Deprecated. JavaScript "javascript" Symbol "symbol" Deprecated. JavaScript code with scope "javascriptWithScope" Deprecated in MongoDB 4.4. 32-bit integer "int" Timestamp "timestamp" 64-bit integer "long" Decimal128 "decimal" Min key -1 "minKey" Max key 127 "maxKey" 
# Show 
```js show dbs show collections ``` 
# Import Data 
```js import from file: mongoimport "D:\Learn\MongoDB\data\persons.json" -d contactData -c contacts --jsonArray ``` 
# Comparison Operators - $eq: equal - $ne: not equal - $gt: greater than - $gte: greater than equal - $lt: lower than - $lte: lower than equal - $in: values specified in an array - $nin: none of values specified in an array # Logical Operators - $or - $nor - $and - $not - $regex - $expr # Array query - $size: to query base on size of an array + only support for exactly value size: {$size: 3} + not support for greater or lower: ```{$size: {$gt:3}}``` - $all: using when dont care about order of item in array ```js db.moviestarts.find({genre: {$all: ["action", "thriller"]}}).pretty() ``` - $elemMatch: ```js db.users.find({hobbies: {$elemMatch: {title: "Sports", frequency: {$gte: 3}}}}).pretty() ``` - ```$slice```: modifier limits the number of array elements during a $push operation # Update Operations - updateOne() - updateMany() - $set: - $inc: increment ```js db.users.updateOne({name: "Manuel"}, {$inc: {age: 2}}) ``` - $min - $max ```js db.users.updateOne({name: "Chris"}, {$max: {age: 32}}) - $mul: multiply -> nhÃ¢n ```js db.users.updateOne({name: "Chris"}, {$mul: {age: 1.1}}) - $unset: deletes a particular field. ```js db.users.updateMany({isSporty: true}, {$unset: {phone: ""}}) ``` -> remove "phone" field from collection - $rename: rename a particular field. ```js db.users.updateMany({}, {$rename: {age: "totalAge"}}) - upsert(): if ele not exists to update -> create new one ```js db.users.updateOne( {name: "Maria"}, {$set: { age: 29, hobbies: [{title: "Good food", frequency: 3}], isSporty: true } }, {upsert: true}) - $[]: update all array elements ```js db.users.updateMany({totalAge: {$gt: 30}}, {$inc: {"hobbies.$[].frequency": -1}}) ``` - ```$[<identifier>]```: identifies the array elements that match the arrayFilters conditions for an update operation ```js db.users.updateMany( {"hobbies.frequency" : {$gt: 2}}, {$set : {"hobbies.$[ele].goodFrequency": true}}, {arrayFilters : [{"ele.frequency": {$gt: 2}}] }) - $push: push new ele to array - $each: ```js db.users.updateOne( {name : "Maria"}, {$push : {hobbies: { $each: [ {title: "Good Wine", frequency: 1}, {title: "Hiking", frequency: 2}], $sort : {frequency: -1}, $slice : 1}}} ) - $pull: removes from an existing array all instances of a value or values that match a specified condition. - $pop: removes the first or last element of an array ```js { $pop: { <field>: <-1 | 1>, ... } } ``` - $addToSet: operator adds a value to an array unless the value is already present # Delete Operations - deleteOne() - deleteMany() - drop() - dropDatabase() # Explain - explain(): ```js db.contacts.explain().find({"dob.age": {$gt: 60}}) ``` - explain("queryPlannner"): Show Summary for Excuted Query + Winning Plan - explain("executionStats"): Show Detailed Summary for Executed Query + Winning Plan + Possibly Rejected Plans ```js db.contacts.explain("executionStats").find({"dob.age": {$gt: 60}}) ``` - explain("allPlansExecution"): Show Detailed Summary for Executed Query + Winning Plan + Winning Plan Decision Process # Index - getIndexes(): ```js db.contacts.getIndexes() ``` - createIndex(): ```js db.contacts.createIndex({"dob.age": 1}) db.contacts.createIndex({"dob.age": 1, gender: 1}) db.contacts.createIndex({"email": 1}, {unique: true}) db.contacts.createIndex({gender: 1}, {partialFilterExpression: {gender: "male"}}) db.contacts.createIndex({email: 1}, { unique: true, partialFilterExpression: {email: {$exists: true}}}) ``` - Time-To-Live (TTL) index: destroy documents after expire time ```js db.sessions.createIndex({createdAt: 1}, {expireAfterSeconds: 10}) ``` - Text Indexes - Only 1 text index per collection - text will always transfer to lowercase ```js db.products.createIndex({description: "text"}) db.products.find({$text: {$search: "awesome"}}) db.products.find({$text: {$search: "awesome book"}}) ``` -> search all product that have "awesome" or "book" ```js db.products.find({$text: {$search: "\"awesome book\""}}) ``` -> search by the whole text: "awesome book" ```js db.products.find({$text: {$search: "awesome t-shirt"}}, {score: {$meta : "textScore"}} ).sort({score: {$meta: "textScore"}}) ``` -> $meta: "textScore" return the score of the result that match the $search condition - Default Language & Using Weights: ```js db.products.createIndex({title : "text", description: "text"}, {default_language : "english"}, {weights : {title: 1, description: 10}}) ``` - To improve the performance of non-English text search queries, you can specify a different default language associated with your text index. - The weight of an indexed field indicates the significance of the field relative to the other indexed fields, with higher weights resulting in higher text search scores. - Build Indexes in the Background: ```js db.ratings.createIndex({age: 1}, {background: true}) ``` - Background index construction allows read and write operations to continue while building the index. - dropIndex(): ```js db.contacts.dropIndex({"dob.age": 1}) db.contacts.dropIndex({"dob.age_1"}) ``` # Aggregation - Collection -> ```{$match}``` -> ```{$group}``` -> ```{$project}``` -> ```{$sort}``` -> Output - Each stage receives the output of the last stage ```js db.contacts.aggregate([ {$match : { gender : "female"}}, {$group : { _id : {state: "$location.state"}, totalPersons : {$sum : 1}}}, {$sort : { totalPersons: -1}}, {$project : { _id: 0, gender: 1, fullName: { $concat: ["$name.first", "$name.last"]}}} ]).pretty() db.contacts.aggregate([ {$project: { _id : 0, gender : 1, fullName : { $concat:[ {$toUpper : { $substrCP: ['$name.first', 0, 1]}}, {$substrCP : [ '$name.first', 1, {$subtract: [{$strLenCP: '$name.first'}, 1]} ]}, " ", "$name.last" ]} }}]).pretty() - $convert: convert field type to different type - $toDate: a shortcut to convert field type to date - $isoWeekYear: a shortcut to convert field type to IsoWeekYear ## Aggregation with array field ## - $push: push new elements Into new create array ```js db.friends.aggregate([ { $group: { _id : {age: "$age"}, allHobbies : {$push: "$hobbies"}}} ]) - $addToSet: push new elements Into new create array but avoid duplicate ```js db.friends.aggregate([ { $group: { _id : {age: "$age"}, allHobbies : {$addToSet: "$hobbies"}}} ]) - $unwind: flattens the array by merge the document that held the array to the array element ```js db.friends.aggregate([ {$unwind: "$hobbies"} ]).pretty() - $slice: returns a subset of an array ```js db.friends.aggregate([ { $project: {_id: 0, examScore: {$slice: ["$examScores", 2]}}} ]) - $size: get the length of an array ```js db.friends.aggregate([ { $project: {_id: 0, numScores: {$size: "$examScores"}}} ]) - $filter: filter an array field of a document ```js db.friends.aggregate([ {$project: { _id: 0, scores: {$filter: { input : '$examScores', as : 'sc', cond : {$gt: ["$$sc.score", 60]} }} }} ]) ## - $bucket: Categorizes incoming documents into groups ```js db.persons.aggregate([ {$bucket: { groupBy : '$dob.age', boundaries : [18, 30, 40, 50, 60, 120], output : { numPersons: {$sum: 1}, averageAge: {$avg: "$dob.age"}} }} ]) - $bucketAuto: Categorizes incoming documents into a specific number of groups ```js db.persons.aggregate([ {$bucketAuto: { groupBy : '$dob.age', buckets : 5, output : { numPersons: {$sum: 1}, averageAge: {$avg: '$dob.age'}} }} ]) - $limit: Limits the number of documents passed to the next stage in the pipeline. - $out: store aggregation pipeline output to a collection ```js db.persons.aggregate([ {$match : {gender: "male"}}, {$project : {_id: 0, name: 1, birthdate: {$toDate: "$dob.date"}}} {$sort : {birthdate: 1}}, {$skip : 10}, {$limit : 10}, {$out : "transformPersons"} ]) - $geoNear: Outputs documents in order of nearest to farthest from a specified point. - Has to be the first stage in aggregation pipeline (Because it get value exact from the document) ```js db.transformPersons.aggregate([ {$geoNear: { near : { type : 'Point', coordinates : [-18.4, -42.8]}, maxDistance : 100000, num : 10, query : {age: {$gt: 30}}, distanceField : "distance" }} ]) ``` - $lookup: Performs a left outer join ```js {$lookup: { from: <collection to join>, localField: <field from the input documents>, foreignField: <field from the documents of the "from" collection>, as: <output array field> } } ``` # Numeric Data - Int 32: - Maximum value: 2147483647 ```js db.companies.insertOne({valuation: NumberInt("2147483647")}) ``` - Int 64 - long integer: - This is default number type of nodejs mongodb when insert a number ```js db.companies.insertOne({valuation: NumberLong("2147483648")}) db.companies.insertOne({valuation: 2147483648}) ``` - double 64 - float: ```js db.companies.insertOne({valuation: 4.2}) ``` - decimal 128: ```js db.companies.insertOne({valuation: NumberDecimal("4.2147483648")}) ``` # Performance & Fault Tolerancy ## Capped collections - Capped collections are created in advance and are fixed in size - Normal collections are created dynamically and automatically grow in size to fit extra data - Capped collections are designed to consume less space and are rotating - Once allocated space is full, it will start writing from older documents again - Below operations are not allowed on a capped collection: - Documents can not be removed - Updates that make documents to grow in size are not allowed - Create Capped collections for cases: want to clear old data automatically - Create collection: ```js db.createCollection("newCappedCol", {capped: true, size: 10000, max: 3}) ``` - InserOne: ```js db.newCappedCol.InserOne({name: "Max"}) ``` - sort($natural: -1): sort capped collection in reverse order when insert ```js db.newCappedCol.find().sort({$natural: -1}) ``` ## Replica sets: - What: Create secondary node from the primarynode for database ```js ClientApp Driver | Write/Read V Primary Replication/ \Replication V V Secondary Secondary ``` - Why: - Backup/Fault Tolerancy (with automatic recovery) - Improve Read Performance ## Sharding: Horizontal Scaling - Allow to scale MongoDB server Horizontally # Transactions ```js const session = db.getMongo().startSession() session.startTransaction() const usersColl = session.getDatabase("blog").users const postsColl = session.getDatabase("blog").posts usersColl.deleteOne({_id: ObjectId("123")}) postsColl.deleteMany({userId: ObjectId("123")}) session.commitTransaction() OR session.abortTransaction() ``` - Implicit Create Operations ```js db.collection.findAndModify() db.collection.findOneAndReplace() db.collection.findOneAndUpdate() db.collection.insertMany() db.collection.insertOne() db.collection.updateOne() db.collection.updateMany() db.collection.replaceOne() db.collection.bulkWrite() ``` # Drivers - Splitting Drivers & Shell ```js Shell | Driver Configure Database | CRUD Operations Create Collections | Aggregation Pipelines Create Indexes | ``` # NodeJS Driver - Connect NodeJS ```js const uri = "mongodb+srv://dattm4:<password>@cluster0.fkqrem0.mongodb.net/shop?retryWrites=true&w=majority"; const mongodb = require('mongodb'); const MongoClient = mongodb.MongoClient; ``` - More realistic setup ```js const mongodb = require('mongodb'); const MongoClient = mongodb.MongoClient; const mongoDbUrl = 'mongodb+srv://dattm4:dat78910@cluster0.fkqrem0.mongodb.net/shop?retryWrites=true&w=majority' let _db; const initDb = callback => { if (_db) { console.log('Database is already initialized!'); return callback(null, _db); } MongoClient.connect(mongoDbUrl) .then(client => { _db = client.db(); callback(null, _db); }) .catch(err => { callback(err); }) } const getDb = () => { if(!_db) { throw Error('Database not initialized'); } return _db; } module.exports = { initDb, getDb } ``` ```js db.initDb((err, db) => { if(err) { console.log(err); } else { app.listen(3100); } }); ``` - insertOne() ```js const Decimal128 = mongodb.Decimal128; router.post('', (req, res, next) => { const newProduct = { name: req.body.name, description: req.body.description, price: Decimal128.fromString(req.body.price.toString()), // store this as 128bit decimal in MongoDB image: req.body.image }; db.getDb().db().collection('products') .insertOne(newProduct) .then(result => { console.log(result); client.close(); }) .catch(err => { console.log(err); client.close(); }); }); ``` - find(): ```js router.get('/', (req, res, next) => { const products = []; db.getDb().db().collection('products') .find() .forEach(productDoc => { productDoc.price = productDoc.price.toString() products.push(productDoc) }) .then(result => { client.close(); res.status(200).json(products); }) .catch(err => { console.log(err); client.close(); res.status(5500).json({ message: 'An error occurred.' }); }); }); ``` - findOne(): ```js const ObjectId = mongodb.ObjectId; router.get('/:id', (req, res, next) => { db.getDb().db() .collection('products') .findOne({ _id: new ObjectId(req.params.id) }) .then(productDoc => { productDoc.price = productDoc.price.toString(); res.status(200), json(productDoc); }) .catch(err => { console.log(err); res.status(500).json({ message: 'An error occured.' }); }); res.json(product); }); ``` - updateOne(): ```js router.patch('/:id', (req, res, next) => { const updatedProduct = { name: req.body.name, description: req.body.description, price: Decimal128.fromString(req.body.price.toString()), // store this as 128bit decimal in MongoDB image: req.body.image }; db.getDb().db().collection('products') .updateOne( { _id: new ObjectId(req.params.id) }, { $set: updatedProduct } ) .then(result => { res.status(200).json({ message: 'Product updated', productId: req.params.id }); }) .catch(err => { console.log(err); res.status(500).json({ message: 'An error occured.' }); }); }); ``` - deleteOne(): ```js router.delete('/:id', (req, res, next) => { db.getDb().db().collection('products') .deleteOne({ _id: new ObjectId(req.params.id) }) .then(result => { res.status(200).json({ message: 'Product deleted' }); }) .catch(err => { console.log(err); res.status(500).json({ message: 'An error occured.' }); }); }); ``` - pagination: ```js router.get('/', (req, res, next) => { const queryPage = req.query.page; const pageSize = 1; const products = []; db.getDb().db().collection('products') .find() .sort({ price: -1 }) .skip((queryPage - 1) * pageSize) .limit(pageSize) ... }); ```
